

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>analysis.diff &mdash; Differentiable Z&#39; → tt̄ Analysis Framework 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=01f34227"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Differentiable Z' → tt̄ Analysis Framework
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../configuration.html">Configuration Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../concepts.html">Core Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mva.html">Multi-Variate Analysis (MVA)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../extending.html">Extending the Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/modules.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Differentiable Z' → tt̄ Analysis Framework</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">analysis.diff</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for analysis.diff</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="c1"># =============================================================================</span>
<span class="c1"># Standard Library Imports</span>
<span class="c1"># =============================================================================</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">hashlib</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pformat</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span>

<span class="c1"># =============================================================================</span>
<span class="c1"># Third-Party Imports</span>
<span class="c1"># =============================================================================</span>
<span class="kn">import</span> <span class="nn">cloudpickle</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">jax</span>
<span class="kn">import</span> <span class="nn">jax.numpy</span> <span class="k">as</span> <span class="nn">jnp</span>
<span class="kn">from</span> <span class="nn">jaxopt</span> <span class="kn">import</span> <span class="n">OptaxSolver</span>
<span class="kn">import</span> <span class="nn">optax</span>
<span class="kn">import</span> <span class="nn">awkward</span> <span class="k">as</span> <span class="nn">ak</span>
<span class="kn">import</span> <span class="nn">uproot</span>
<span class="kn">import</span> <span class="nn">vector</span>
<span class="kn">from</span> <span class="nn">coffea.analysis_tools</span> <span class="kn">import</span> <span class="n">PackedSelection</span>
<span class="kn">from</span> <span class="nn">coffea.nanoevents</span> <span class="kn">import</span> <span class="n">NanoAODSchema</span><span class="p">,</span> <span class="n">NanoEventsFactory</span>

<span class="c1"># =============================================================================</span>
<span class="c1"># Project Imports</span>
<span class="c1"># =============================================================================</span>
<span class="kn">from</span> <span class="nn">analysis.base</span> <span class="kn">import</span> <span class="n">Analysis</span>
<span class="kn">from</span> <span class="nn">utils.cuts</span> <span class="kn">import</span> <span class="n">lumi_mask</span>
<span class="kn">from</span> <span class="nn">utils.mva</span> <span class="kn">import</span> <span class="n">JAXNetwork</span><span class="p">,</span> <span class="n">TFNetwork</span>
<span class="kn">from</span> <span class="nn">utils.preproc</span> <span class="kn">import</span> <span class="n">pre_process_dak</span><span class="p">,</span> <span class="n">pre_process_uproot</span>
<span class="kn">from</span> <span class="nn">utils.jax_stats</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">calculate_significance_relaxed</span><span class="p">,</span>
    <span class="n">build_allbkg_channel_data_scalar</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">utils.plot</span> <span class="kn">import</span> <span class="n">plot_cms_histogram</span><span class="p">,</span> <span class="n">plot_params_per_iter</span><span class="p">,</span> <span class="n">plot_pval_history</span>

<span class="c1"># =============================================================================</span>
<span class="c1"># Backend &amp; Logging Setup</span>
<span class="c1"># =============================================================================</span>
<span class="n">ak</span><span class="o">.</span><span class="n">jax</span><span class="o">.</span><span class="n">register_and_check</span><span class="p">()</span>
<span class="n">vector</span><span class="o">.</span><span class="n">register_awkward</span><span class="p">()</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;DiffAnalysis&quot;</span><span class="p">)</span>
<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span>
    <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
    <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;[</span><span class="si">%(levelname)s</span><span class="s2">: </span><span class="si">%(name)s</span><span class="s2"> - </span><span class="si">%(lineno)d</span><span class="s2"> - </span><span class="si">%(funcName)20s</span><span class="s2">()] </span><span class="si">%(message)s</span><span class="s2">&quot;</span>
<span class="p">)</span>
<span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;jax._src.xla_bridge&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">ERROR</span><span class="p">)</span>

<span class="n">NanoAODSchema</span><span class="o">.</span><span class="n">warn_missing_crossrefs</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="s2">&quot;coffea.*&quot;</span><span class="p">)</span>

<span class="n">GREEN</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\033</span><span class="s2">[92m&quot;</span>
<span class="n">RESET</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\033</span><span class="s2">[0m&quot;</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Utility functions</span>
<span class="c1"># -----------------------------------------------------------------------------</span>

<div class="viewcode-block" id="merge_histograms">
<a class="viewcode-back" href="../../api/analysis.html#analysis.diff.merge_histograms">[docs]</a>
<span class="k">def</span> <span class="nf">merge_histograms</span><span class="p">(</span>
    <span class="n">existing_histograms</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]],</span>
    <span class="n">new_histograms</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively merge new histograms into an existing nested histogram structure.</span>

<span class="sd">    Each histogram is assumed to follow the structure:</span>
<span class="sd">    histograms[variation][region][observable] = jnp.ndarray</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    existing_histograms : dict</span>
<span class="sd">        Existing nested histogram structure to be updated.</span>
<span class="sd">    new_histograms : dict</span>
<span class="sd">        New histogram data to merge in.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        The updated nested histogram structure with new data merged in.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">variation</span><span class="p">,</span> <span class="n">region_data</span> <span class="ow">in</span> <span class="n">new_histograms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">region</span><span class="p">,</span> <span class="n">observable_data</span> <span class="ow">in</span> <span class="n">region_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">observable</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">observable_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># Ensure region exists under the current variation</span>
                <span class="n">existing_histograms</span><span class="p">[</span><span class="n">variation</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="p">{})</span>
                <span class="c1"># Merge or initialise the observable histogram</span>
                <span class="k">if</span> <span class="n">observable</span> <span class="ow">in</span> <span class="n">existing_histograms</span><span class="p">[</span><span class="n">variation</span><span class="p">][</span><span class="n">region</span><span class="p">]:</span>
                    <span class="n">existing_histograms</span><span class="p">[</span><span class="n">variation</span><span class="p">][</span><span class="n">region</span><span class="p">][</span><span class="n">observable</span><span class="p">]</span> <span class="o">+=</span> <span class="n">array</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">existing_histograms</span><span class="p">[</span><span class="n">variation</span><span class="p">][</span><span class="n">region</span><span class="p">][</span><span class="n">observable</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span>
    <span class="k">return</span> <span class="n">existing_histograms</span></div>



<div class="viewcode-block" id="recursive_to_backend">
<a class="viewcode-back" href="../../api/analysis.html#analysis.diff.recursive_to_backend">[docs]</a>
<span class="k">def</span> <span class="nf">recursive_to_backend</span><span class="p">(</span><span class="n">data_structure</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;jax&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively convert all Awkward Arrays in a data structure to the specified backend.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data_structure : Any</span>
<span class="sd">        Input data structure possibly containing Awkward Arrays.</span>
<span class="sd">    backend : str</span>
<span class="sd">        Target backend to convert arrays to (e.g. &#39;jax&#39;, &#39;cpu&#39;).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Any</span>
<span class="sd">        Data structure with Awkward Arrays converted to the desired backend.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_structure</span><span class="p">,</span> <span class="n">ak</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
        <span class="c1"># Convert only if not already on the target backend</span>
        <span class="k">return</span> <span class="n">ak</span><span class="o">.</span><span class="n">to_backend</span><span class="p">(</span><span class="n">data_structure</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span> <span class="k">if</span> <span class="n">ak</span><span class="o">.</span><span class="n">backend</span><span class="p">(</span><span class="n">data_structure</span><span class="p">)</span> <span class="o">!=</span> <span class="n">backend</span> <span class="k">else</span> <span class="n">data_structure</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_structure</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
        <span class="c1"># Recurse into dictionary values</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">recursive_to_backend</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data_structure</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_structure</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_structure</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)):</span>
        <span class="c1"># Recurse into list or tuple elements</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">recursive_to_backend</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data_structure</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Leave unchanged if not an Awkward structure</span>
        <span class="k">return</span> <span class="n">data_structure</span></div>



<div class="viewcode-block" id="infer_processes_and_systematics">
<a class="viewcode-back" href="../../api/analysis.html#analysis.diff.infer_processes_and_systematics">[docs]</a>
<span class="k">def</span> <span class="nf">infer_processes_and_systematics</span><span class="p">(</span>
    <span class="n">fileset</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
    <span class="n">systematics_config</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
    <span class="n">corrections_config</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract all unique process and systematic names from the config and fileset.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fileset : dict</span>
<span class="sd">        Dataset structure with &#39;metadata&#39; dictionaries including process names.</span>
<span class="sd">    systematics_config : list</span>
<span class="sd">        Configuration entries for systematic variations.</span>
<span class="sd">    corrections_config : list</span>
<span class="sd">        Configuration entries for object-level corrections.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple[list[str], list[str]]</span>
<span class="sd">        Sorted list of process names and systematic variation base names.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Pull out all process names from the fileset metadata</span>
    <span class="n">process_names</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;process&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">fileset</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">metadata</span> <span class="o">:=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;metadata&quot;</span><span class="p">))</span> <span class="ow">and</span> <span class="n">metadata</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;process&quot;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1"># Extract systematic names from both systematics and corrections configs</span>
    <span class="n">systematic_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">syst</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">syst</span> <span class="ow">in</span> <span class="n">systematics_config</span> <span class="o">+</span> <span class="n">corrections_config</span><span class="p">}</span>

    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">process_names</span><span class="p">),</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">systematic_names</span><span class="p">)</span></div>



<div class="viewcode-block" id="nested_defaultdict_to_dict">
<a class="viewcode-back" href="../../api/analysis.html#analysis.diff.nested_defaultdict_to_dict">[docs]</a>
<span class="k">def</span> <span class="nf">nested_defaultdict_to_dict</span><span class="p">(</span><span class="n">nested_structure</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively convert any nested defaultdicts into standard Python dictionaries.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nested_structure : Any</span>
<span class="sd">        A nested structure possibly containing defaultdicts.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Fully converted structure using built-in dict.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nested_structure</span><span class="p">,</span> <span class="n">defaultdict</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">nested_defaultdict_to_dict</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">nested_structure</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nested_structure</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">nested_defaultdict_to_dict</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">nested_structure</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">return</span> <span class="n">nested_structure</span></div>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Optimisation helper functions</span>
<span class="c1"># -----------------------------------------------------------------------------</span>

<div class="viewcode-block" id="make_apply_param_updates">
<a class="viewcode-back" href="../../api/analysis.html#analysis.diff.make_apply_param_updates">[docs]</a>
<span class="k">def</span> <span class="nf">make_apply_param_updates</span><span class="p">(</span><span class="n">parameter_update_rules</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">callable</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a function that updates parameters using user-defined rules.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parameter_update_rules : dict</span>
<span class="sd">        Mapping from parameter name to update function.</span>
<span class="sd">        Each function should have the form: lambda old_value, delta -&gt; new_value</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    callable</span>
<span class="sd">        Function that applies update rules to a given pair of parameter dictionaries.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">apply_rules</span><span class="p">(</span><span class="n">old_params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">tentative_params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">updated_auxiliary</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">aux_old</span> <span class="o">=</span> <span class="n">old_params</span><span class="p">[</span><span class="s2">&quot;aux&quot;</span><span class="p">]</span>
        <span class="n">aux_new_candidate</span> <span class="o">=</span> <span class="n">tentative_params</span><span class="p">[</span><span class="s2">&quot;aux&quot;</span><span class="p">]</span>

        <span class="c1"># Apply the user-defined update rule for each parameter</span>
        <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">candidate_value</span> <span class="ow">in</span> <span class="n">aux_new_candidate</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">parameter_update_rules</span><span class="p">:</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">candidate_value</span> <span class="o">-</span> <span class="n">aux_old</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span>
                <span class="n">updated_auxiliary</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameter_update_rules</span><span class="p">[</span><span class="n">param_name</span><span class="p">](</span><span class="n">aux_old</span><span class="p">[</span><span class="n">param_name</span><span class="p">],</span> <span class="n">delta</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">updated_auxiliary</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate_value</span>

        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;aux&quot;</span><span class="p">:</span> <span class="n">updated_auxiliary</span><span class="p">,</span> <span class="s2">&quot;fit&quot;</span><span class="p">:</span> <span class="n">tentative_params</span><span class="p">[</span><span class="s2">&quot;fit&quot;</span><span class="p">]}</span>

    <span class="k">return</span> <span class="n">apply_rules</span></div>



<div class="viewcode-block" id="make_clamp_transform">
<a class="viewcode-back" href="../../api/analysis.html#analysis.diff.make_clamp_transform">[docs]</a>
<span class="k">def</span> <span class="nf">make_clamp_transform</span><span class="p">(</span><span class="n">clamp_function</span><span class="p">:</span> <span class="nb">callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">optax</span><span class="o">.</span><span class="n">GradientTransformation</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an Optax transformation that clamps parameters after each update step.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    clamp_function : callable</span>
<span class="sd">        A function that takes (old_params, new_params) and returns clamped new_params.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    optax.GradientTransformation</span>
<span class="sd">        An Optax transformation object with clamping logic.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">init_fn</span><span class="p">(</span><span class="n">initial_params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">update_fn</span><span class="p">(</span>
        <span class="n">parameter_updates</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">state</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">current_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="c1"># Apply standard update</span>
        <span class="n">updated_params</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">apply_updates</span><span class="p">(</span><span class="n">current_params</span><span class="p">,</span> <span class="n">parameter_updates</span><span class="p">)</span>
        <span class="c1"># Clamp values to allowed region</span>
        <span class="n">clamped_params</span> <span class="o">=</span> <span class="n">clamp_function</span><span class="p">(</span><span class="n">current_params</span><span class="p">,</span> <span class="n">updated_params</span><span class="p">)</span>
        <span class="c1"># Compute difference between clamped and original values</span>
        <span class="n">effective_updates</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">tree_util</span><span class="o">.</span><span class="n">tree_map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">:</span> <span class="n">new</span> <span class="o">-</span> <span class="n">old</span><span class="p">,</span> <span class="n">clamped_params</span><span class="p">,</span> <span class="n">current_params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">effective_updates</span><span class="p">,</span> <span class="n">state</span>

    <span class="k">return</span> <span class="n">optax</span><span class="o">.</span><span class="n">GradientTransformation</span><span class="p">(</span><span class="n">init_fn</span><span class="p">,</span> <span class="n">update_fn</span><span class="p">)</span></div>



<div class="viewcode-block" id="make_lr_and_clamp_transform">
<a class="viewcode-back" href="../../api/analysis.html#analysis.diff.make_lr_and_clamp_transform">[docs]</a>
<span class="k">def</span> <span class="nf">make_lr_and_clamp_transform</span><span class="p">(</span>
    <span class="n">auxiliary_lr_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="n">default_auxiliary_lr</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">default_fit_lr</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">neural_net_lr_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="n">clamp_function</span><span class="p">:</span> <span class="nb">callable</span><span class="p">,</span>
    <span class="n">frozen_parameter_keys</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">callable</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an optimiser builder combining learning-rate scheduling and clamping.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    auxiliary_lr_map : dict</span>
<span class="sd">        Custom learning rates for specific auxiliary parameters.</span>
<span class="sd">    default_auxiliary_lr : float</span>
<span class="sd">        Default learning rate for auxiliary parameters not in lr_map.</span>
<span class="sd">    default_fit_lr : float</span>
<span class="sd">        Learning rate for &#39;fit&#39; parameters.</span>
<span class="sd">    neural_net_lr_map : dict</span>
<span class="sd">        Learning rates for neural network parameters.</span>
<span class="sd">    clamp_function : callable</span>
<span class="sd">        Projection function that clamps parameters within valid bounds.</span>
<span class="sd">    frozen_parameter_keys : set[str], optional</span>
<span class="sd">        Set of parameter names to freeze (prevent updates).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    callable</span>
<span class="sd">        A builder function that returns (optax_transform, label_mapping).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">frozen_parameter_keys</span> <span class="o">=</span> <span class="n">frozen_parameter_keys</span> <span class="ow">or</span> <span class="nb">set</span><span class="p">()</span>

    <span class="c1"># Build learning-rate schedule map for different parameter groups</span>
    <span class="n">sub_transforms</span> <span class="o">=</span> <span class="p">{</span>
        <span class="o">**</span><span class="p">{</span><span class="sa">f</span><span class="s2">&quot;aux__</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">optax</span><span class="o">.</span><span class="n">adam</span><span class="p">(</span><span class="n">lr</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">lr</span> <span class="ow">in</span> <span class="n">auxiliary_lr_map</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
        <span class="o">**</span><span class="p">{</span><span class="sa">f</span><span class="s2">&quot;NN__</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">optax</span><span class="o">.</span><span class="n">adam</span><span class="p">(</span><span class="n">lr</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">lr</span> <span class="ow">in</span> <span class="n">neural_net_lr_map</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
        <span class="s2">&quot;aux__default&quot;</span><span class="p">:</span> <span class="n">optax</span><span class="o">.</span><span class="n">adam</span><span class="p">(</span><span class="n">default_auxiliary_lr</span><span class="p">),</span>
        <span class="s2">&quot;NN__default&quot;</span><span class="p">:</span> <span class="n">optax</span><span class="o">.</span><span class="n">adam</span><span class="p">(</span><span class="n">default_auxiliary_lr</span><span class="p">),</span>
        <span class="s2">&quot;fit__default&quot;</span><span class="p">:</span> <span class="n">optax</span><span class="o">.</span><span class="n">adam</span><span class="p">(</span><span class="n">default_fit_lr</span><span class="p">),</span>
        <span class="s2">&quot;no_update&quot;</span><span class="p">:</span> <span class="n">optax</span><span class="o">.</span><span class="n">set_to_zero</span><span class="p">(),</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="nf">make_label_pytree</span><span class="p">(</span><span class="n">parameter_tree</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a label tree assigning each parameter to a named sub-transform.&quot;&quot;&quot;</span>
        <span class="n">label_tree</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;aux&quot;</span><span class="p">:</span> <span class="p">{},</span> <span class="s2">&quot;fit&quot;</span><span class="p">:</span> <span class="p">{}}</span>

        <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">parameter_tree</span><span class="p">[</span><span class="s2">&quot;aux&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">frozen_parameter_keys</span><span class="p">:</span>
                <span class="n">label_tree</span><span class="p">[</span><span class="s2">&quot;aux&quot;</span><span class="p">][</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;no_update&quot;</span>
            <span class="k">elif</span> <span class="s2">&quot;__NN&quot;</span> <span class="ow">in</span> <span class="n">param_name</span><span class="p">:</span>
                <span class="c1"># Use specific NN LR if matched, otherwise fall back to default</span>
                <span class="n">label_tree</span><span class="p">[</span><span class="s2">&quot;aux&quot;</span><span class="p">][</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
                    <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;NN__</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">neural_net_lr_map</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">param_name</span><span class="p">),</span>
                    <span class="s2">&quot;NN__default&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">auxiliary_lr_map</span><span class="p">:</span>
                <span class="n">label_tree</span><span class="p">[</span><span class="s2">&quot;aux&quot;</span><span class="p">][</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;aux__</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">label_tree</span><span class="p">[</span><span class="s2">&quot;aux&quot;</span><span class="p">][</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;aux__default&quot;</span>

        <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">parameter_tree</span><span class="p">[</span><span class="s2">&quot;fit&quot;</span><span class="p">]:</span>
            <span class="n">label_tree</span><span class="p">[</span><span class="s2">&quot;fit&quot;</span><span class="p">][</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;no_update&quot;</span> <span class="k">if</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">frozen_parameter_keys</span> <span class="k">else</span> <span class="s2">&quot;fit__default&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">label_tree</span>

    <span class="k">def</span> <span class="nf">optimiser_builder</span><span class="p">(</span><span class="n">initial_params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">optax</span><span class="o">.</span><span class="n">GradientTransformation</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>
        <span class="c1"># Map each parameter to its optimiser label</span>
        <span class="n">label_mapping</span> <span class="o">=</span> <span class="n">make_label_pytree</span><span class="p">(</span><span class="n">initial_params</span><span class="p">)</span>
        <span class="c1"># Chain the learning rate transform with clamping logic</span>
        <span class="n">optimiser</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
            <span class="n">optax</span><span class="o">.</span><span class="n">multi_transform</span><span class="p">(</span><span class="n">sub_transforms</span><span class="p">,</span> <span class="n">label_mapping</span><span class="p">),</span>
            <span class="n">make_clamp_transform</span><span class="p">(</span><span class="n">clamp_function</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">optimiser</span><span class="p">,</span> <span class="n">label_mapping</span>

    <span class="k">return</span> <span class="n">optimiser_builder</span></div>



<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># DifferentiableAnalysis Class Definition</span>
<span class="c1"># -----------------------------------------------------------------------------</span>
<div class="viewcode-block" id="DifferentiableAnalysis">
<a class="viewcode-back" href="../../api/analysis.html#analysis.diff.DifferentiableAnalysis">[docs]</a>
<span class="k">class</span> <span class="nc">DifferentiableAnalysis</span><span class="p">(</span><span class="n">Analysis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Differentiable statistical analysis implementation.</span>

<span class="sd">    This class extends the base `Analysis` class to support differentiable workflows,</span>
<span class="sd">    including:</span>
<span class="sd">    - Managing histograms with JAX-compatible data structures.</span>
<span class="sd">    - Preparing directory structure for outputs, caches, and plots.</span>
<span class="sd">    - Applying selections per analysis channel for both analysis and MVA data branches.</span>
<span class="sd">    - Training MVA models using JAX or TensorFlow frameworks.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DifferentiableAnalysis.__init__">
<a class="viewcode-back" href="../../api/analysis.html#analysis.diff.DifferentiableAnalysis.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialise the DifferentiableAnalysis with configuration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        config : dict</span>
<span class="sd">            Analysis configuration dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>

        <span class="c1"># Histogram storage:</span>
        <span class="c1"># histograms[variation][region][observable] = jnp.ndarray</span>
        <span class="c1"># Used for storing the final outputs from the differentiable histogramming step.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">histograms</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span>
            <span class="k">lambda</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_dirs</span><span class="p">()</span></div>



    <span class="k">def</span> <span class="nf">_set_histograms</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">histograms</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set final histograms after processing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        histograms : dict</span>
<span class="sd">            Histogram dictionary to store.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Replace the current histogram store with new results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">histograms</span> <span class="o">=</span> <span class="n">histograms</span>


    <span class="k">def</span> <span class="nf">_prepare_dirs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create necessary output directories for analysis results.</span>

<span class="sd">        This includes:</span>
<span class="sd">        - General output directory structure</span>
<span class="sd">        - Cache directory for storing gradients</span>
<span class="sd">        - Optional preprocessed input directory</span>
<span class="sd">        - Directories for storing MVA models, optimisation plots, and fit plots</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure the output/ directory and common structure are prepared</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dirs</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_prepare_dirs</span><span class="p">()</span>

        <span class="c1"># Create cache directory for gradient checkpoints and intermediate results</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">cache_dir</span> <span class="ow">or</span> <span class="s2">&quot;/tmp/gradients_analysis/&quot;</span><span class="p">)</span>
        <span class="n">cache</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Optional: directory to store preprocessed inputs for later reuse</span>
        <span class="n">preproc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;preprocessed_dir&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">preproc</span><span class="p">:</span>
            <span class="n">Path</span><span class="p">(</span><span class="n">preproc</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Directory for trained MVA models</span>
        <span class="n">mva</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirs</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="s2">&quot;mva_models&quot;</span>
        <span class="n">mva</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Output plots from analysis cut optimisation step</span>
        <span class="n">optimisation_plots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirs</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="s2">&quot;plots&quot;</span> <span class="o">/</span> <span class="s2">&quot;optimisation&quot;</span>
        <span class="n">optimisation_plots</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Output plots from fit or profiling stage</span>
        <span class="n">fit_plots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirs</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="s2">&quot;plots&quot;</span> <span class="o">/</span> <span class="s2">&quot;fit&quot;</span>
        <span class="n">fit_plots</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Register the created paths in the analysis directory registry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dirs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
            <span class="s2">&quot;cache&quot;</span><span class="p">:</span>       <span class="n">cache</span><span class="p">,</span>
            <span class="s2">&quot;preproc&quot;</span><span class="p">:</span>     <span class="n">Path</span><span class="p">(</span><span class="n">preproc</span><span class="p">)</span> <span class="k">if</span> <span class="n">preproc</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;mva_models&quot;</span><span class="p">:</span>  <span class="n">mva</span><span class="p">,</span>
            <span class="s2">&quot;optimisation_plots&quot;</span><span class="p">:</span> <span class="n">optimisation_plots</span><span class="p">,</span>
            <span class="s2">&quot;fit_plots&quot;</span><span class="p">:</span> <span class="n">fit_plots</span><span class="p">,</span>
        <span class="p">})</span>



    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Data categorisation (channels)</span>
    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_get_channel_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">object_copies_analysis</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ak</span><span class="o">.</span><span class="n">Array</span><span class="p">],</span>
        <span class="n">events_analysis</span><span class="p">:</span> <span class="n">ak</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
        <span class="n">object_copies_mva</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ak</span><span class="o">.</span><span class="n">Array</span><span class="p">],</span>
        <span class="n">events_mva</span><span class="p">:</span> <span class="n">ak</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
        <span class="n">process</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">variation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply per-channel selection to the corrected object and event collections,</span>
<span class="sd">        and return selected data for both physics analysis and MVA pre-training.</span>

<span class="sd">        This function performs selection using the analysis branch and returns:</span>
<span class="sd">        - selected objects and events for histogramming (from analysis branch)</span>
<span class="sd">        - selected objects and events for MVA pre-training (from MVA branch)</span>
<span class="sd">        - total number of selected events from each branch</span>
<span class="sd">        - unmasked inputs in a &#39;__presel&#39; entry</span>

<span class="sd">        See docstring inside `apply_selection` for further details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">process</span> <span class="o">==</span> <span class="s2">&quot;data&quot;</span> <span class="ow">and</span> <span class="n">variation</span> <span class="o">!=</span> <span class="s2">&quot;nominal&quot;</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping </span><span class="si">{</span><span class="n">variation</span><span class="si">}</span><span class="s2"> for data&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="k">def</span> <span class="nf">apply_selection</span><span class="p">(</span>
            <span class="n">channel</span><span class="p">,</span>
            <span class="n">object_copies</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ak</span><span class="o">.</span><span class="n">Array</span><span class="p">],</span>
            <span class="n">events</span><span class="p">:</span> <span class="n">ak</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
            <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ak</span><span class="o">.</span><span class="n">Array</span><span class="p">],</span> <span class="n">ak</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ak</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Apply selection function to the input objects and events.</span>

<span class="sd">            This runs the channel-specific selection function (typically returning a</span>
<span class="sd">            PackedSelection object) and constructs the event mask to use.</span>

<span class="sd">            For data samples, applies the certified luminosity mask afterwards.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            channel : object</span>
<span class="sd">                Analysis channel containing selection information.</span>
<span class="sd">            object_copies : dict[str, ak.Array]</span>
<span class="sd">                Corrected object collections.</span>
<span class="sd">            events : ak.Array</span>
<span class="sd">                Corresponding events.</span>
<span class="sd">            label : str</span>
<span class="sd">                Context label for logging.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            tuple</span>
<span class="sd">                (Selected objects, events, and mask array)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># Ensure data is not backed by JAX (selection not traced)</span>
            <span class="n">events</span> <span class="o">=</span> <span class="n">recursive_to_backend</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
            <span class="n">object_copies</span> <span class="o">=</span> <span class="n">recursive_to_backend</span><span class="p">(</span><span class="n">object_copies</span><span class="p">,</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>

            <span class="c1"># Check for presence of selection logic</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">channel</span><span class="o">.</span><span class="n">selection</span><span class="o">.</span><span class="n">function</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">] No selection function for channel </span><span class="si">{</span><span class="n">channel</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">object_copies</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">ak</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

            <span class="c1"># Extract arguments used by selection function</span>
            <span class="n">sel_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_function_arguments</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">selection</span><span class="o">.</span><span class="n">use</span><span class="p">,</span> <span class="n">object_copies</span><span class="p">)</span>
            <span class="n">packed</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">selection</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">sel_args</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">packed</span><span class="p">,</span> <span class="n">PackedSelection</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Selection function must return PackedSelection&quot;</span><span class="p">)</span>

            <span class="c1"># Generate mask from PackedSelection object</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">ak</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">packed</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">packed</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">recursive_to_backend</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>

            <span class="c1"># Apply certified luminosity filter for data</span>
            <span class="k">if</span> <span class="n">process</span> <span class="o">==</span> <span class="s2">&quot;data&quot;</span><span class="p">:</span>
                <span class="n">good_runs</span> <span class="o">=</span> <span class="n">lumi_mask</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">lumifile</span><span class="p">,</span>
                    <span class="n">object_copies</span><span class="p">[</span><span class="s2">&quot;run&quot;</span><span class="p">],</span>
                    <span class="n">object_copies</span><span class="p">[</span><span class="s2">&quot;luminosityBlock&quot;</span><span class="p">],</span>
                    <span class="n">jax</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">ak</span><span class="o">.</span><span class="n">to_backend</span><span class="p">(</span><span class="n">good_runs</span><span class="p">,</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">] Applied luminosity mask for data&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">object_copies</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">mask</span>

        <span class="c1"># Initialise dictionary for channel-wise outputs, and store unmasked input</span>
        <span class="n">per_channel</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="n">per_channel</span><span class="p">[</span><span class="s2">&quot;__presel&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;objects&quot;</span><span class="p">:</span> <span class="n">object_copies_analysis</span><span class="p">,</span>
            <span class="s2">&quot;events&quot;</span><span class="p">:</span> <span class="n">events_analysis</span><span class="p">,</span>
            <span class="s2">&quot;mva_objects&quot;</span><span class="p">:</span> <span class="n">object_copies_mva</span><span class="p">,</span>
            <span class="s2">&quot;mva_events&quot;</span><span class="p">:</span> <span class="n">events_mva</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># Iterate over all channels defined in configuration</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">channel</span><span class="o">.</span><span class="n">use_in_diff</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping channel </span><span class="si">{</span><span class="n">channel</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> in diff analysis&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">chname</span> <span class="o">=</span> <span class="n">channel</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>

            <span class="c1"># If a subset of channels is requested, skip the rest</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">req</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span> <span class="ow">and</span> <span class="n">chname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">req</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping channel </span><span class="si">{</span><span class="n">chname</span><span class="si">}</span><span class="s2"> (not in requested channels)&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Applying selection for </span><span class="si">{</span><span class="n">chname</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">process</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Run selection and get event-level mask</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">events_analysis_cpu</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">apply_selection</span><span class="p">(</span>
                <span class="n">channel</span><span class="p">,</span> <span class="n">object_copies_analysis</span><span class="p">,</span> <span class="n">events_analysis</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;analysis&quot;</span>
            <span class="p">)</span>

            <span class="c1"># Count number of events passing selection</span>
            <span class="n">n_events</span> <span class="o">=</span> <span class="n">ak</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n_events</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No events left in </span><span class="si">{</span><span class="n">chname</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="n">process</span><span class="si">}</span><span class="s2"> after selection&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Events in </span><span class="si">{</span><span class="n">chname</span><span class="si">}</span><span class="s2">: before=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="si">}</span><span class="s2">, after=</span><span class="si">{</span><span class="n">n_events</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Apply mask to objects and events for both branches</span>
            <span class="n">obj_analysis</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">object_copies_analysis</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">evt_analysis</span> <span class="o">=</span> <span class="n">events_analysis_cpu</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">obj_mva</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">object_copies_mva</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">evt_mva</span> <span class="o">=</span> <span class="n">events_mva</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

            <span class="c1"># Save results to output structure</span>
            <span class="n">per_channel</span><span class="p">[</span><span class="n">chname</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;objects&quot;</span><span class="p">:</span> <span class="n">obj_analysis</span><span class="p">,</span>
                <span class="s2">&quot;events&quot;</span><span class="p">:</span> <span class="n">evt_analysis</span><span class="p">,</span>
                <span class="s2">&quot;nevents&quot;</span><span class="p">:</span> <span class="n">n_events</span><span class="p">,</span>
                <span class="s2">&quot;mva_objects&quot;</span><span class="p">:</span> <span class="n">obj_mva</span><span class="p">,</span>
                <span class="s2">&quot;mva_events&quot;</span><span class="p">:</span> <span class="n">evt_mva</span><span class="p">,</span>
                <span class="s2">&quot;mva_nevents&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">evt_mva</span><span class="p">),</span>
            <span class="p">}</span>

        <span class="k">return</span> <span class="n">per_channel</span>


    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Running training of MVA models</span>
    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_run_mva_training</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">events_per_process</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Train each MVAConfig using the pre-collected object copies and event counts.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        events_per_process : dict</span>
<span class="sd">            Mapping from process name to list of (input dictionary, event count).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict[str, Any]</span>
<span class="sd">            Mapping of MVAConfig name to trained model or parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trained</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">nets</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">mva_cfg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">mva</span><span class="p">:</span>
            <span class="c1"># JAX-based model</span>
            <span class="k">if</span> <span class="n">mva_cfg</span><span class="o">.</span><span class="n">framework</span> <span class="o">==</span> <span class="s2">&quot;jax&quot;</span><span class="p">:</span>
                <span class="n">net</span> <span class="o">=</span> <span class="n">JAXNetwork</span><span class="p">(</span><span class="n">mva_cfg</span><span class="p">)</span>
                <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">,</span> <span class="n">class_weights</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">prepare_inputs</span><span class="p">(</span><span class="n">events_per_process</span><span class="p">)</span>
                <span class="n">Xtr</span><span class="p">,</span> <span class="n">Xvl</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">X_train</span><span class="p">),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">X_val</span><span class="p">)</span>
                <span class="n">ytr</span><span class="p">,</span> <span class="n">yvl</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y_train</span><span class="p">),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y_val</span><span class="p">)</span>
                <span class="n">net</span><span class="o">.</span><span class="n">init_network</span><span class="p">()</span>
                <span class="n">params</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">Xtr</span><span class="p">,</span> <span class="n">ytr</span><span class="p">,</span> <span class="n">Xvl</span><span class="p">,</span> <span class="n">yvl</span><span class="p">)</span>
                <span class="n">trained</span><span class="p">[</span><span class="n">mva_cfg</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span>
                <span class="n">nets</span><span class="p">[</span><span class="n">mva_cfg</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">net</span>

            <span class="c1"># TensorFlow-based model</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">net</span> <span class="o">=</span> <span class="n">TFNetwork</span><span class="p">(</span><span class="n">mva_cfg</span><span class="p">)</span>
                <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">,</span> <span class="n">class_weights</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">prepare_inputs</span><span class="p">(</span><span class="n">events_per_process</span><span class="p">)</span>
                <span class="n">net</span><span class="o">.</span><span class="n">init_network</span><span class="p">()</span>
                <span class="n">sw_train</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># Optional: apply class-balancing weights to training</span>
                <span class="k">if</span> <span class="n">class_weights</span> <span class="ow">and</span> <span class="n">mva_cfg</span><span class="o">.</span><span class="n">balance_strategy</span> <span class="o">==</span> <span class="s2">&quot;class_weight&quot;</span><span class="p">:</span>
                    <span class="n">sw_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">class_weights</span><span class="o">.</span><span class="n">get</span><span class="p">)(</span><span class="n">y_train</span><span class="p">)</span>

                <span class="n">fit_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;sample_weight&quot;</span><span class="p">:</span> <span class="n">sw_train</span><span class="p">}</span> <span class="k">if</span> <span class="n">sw_train</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}</span>
                <span class="n">model</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_kwargs</span><span class="p">)</span>
                <span class="n">trained</span><span class="p">[</span><span class="n">mva_cfg</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span>
                <span class="n">nets</span><span class="p">[</span><span class="n">mva_cfg</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">net</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Finished training MVA &#39;</span><span class="si">{</span><span class="n">mva_cfg</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">trained</span><span class="p">,</span> <span class="n">nets</span>


    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Preparing data for JAX (untraced)</span>
    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_prepare_data_for_tracing</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">events</span><span class="p">:</span> <span class="n">ak</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
        <span class="n">process</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Preprocess events without JAX tracing for systematic variations.</span>

<span class="sd">        This method performs baseline selection and object correction, then</span>
<span class="sd">        returns all data needed to fill histograms per systematic variation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        events : ak.Array</span>
<span class="sd">            Raw NanoAOD events.</span>
<span class="sd">        process : str</span>
<span class="sd">            Sample label (e.g. &quot;ttbar&quot;, &quot;data&quot;).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary mapping variation names to channel-wise data structures.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">processed_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting untraced processing for </span><span class="si">{</span><span class="n">process</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">prepare_full_obj_copies</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">mask_set</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Perform object copying, masking, baseline selection, correction,</span>
<span class="sd">            and ghost observable computation.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            events : ak.Array</span>
<span class="sd">                Raw event data.</span>
<span class="sd">            mask_set : str</span>
<span class="sd">                Name of mask set to apply.</span>
<span class="sd">            label : str</span>
<span class="sd">                Label for logging.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            tuple</span>
<span class="sd">                (masked object copies, corrected objects, selection mask)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># Copy objects and apply good-object masks</span>
            <span class="n">obj_copies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_object_copies</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
            <span class="n">obj_copies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_object_masks</span><span class="p">(</span><span class="n">obj_copies</span><span class="p">,</span> <span class="n">mask_set</span><span class="o">=</span><span class="n">mask_set</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">] Created object copies and applied &#39;</span><span class="si">{</span><span class="n">mask_set</span><span class="si">}</span><span class="s2">&#39; masks&quot;</span><span class="p">)</span>

            <span class="c1"># Move all arrays to CPU for baseline selection</span>
            <span class="n">events_cpu</span> <span class="o">=</span> <span class="n">recursive_to_backend</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
            <span class="n">obj_copies</span> <span class="o">=</span> <span class="n">recursive_to_backend</span><span class="p">(</span><span class="n">obj_copies</span><span class="p">,</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>

            <span class="c1"># Apply baseline selection mask</span>
            <span class="n">baseline_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_function_arguments</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">baseline_selection</span><span class="p">[</span><span class="s2">&quot;use&quot;</span><span class="p">],</span> <span class="n">obj_copies</span>
            <span class="p">)</span>
            <span class="n">packed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">baseline_selection</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">](</span><span class="o">*</span><span class="n">baseline_args</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">ak</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">packed</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">packed</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">recursive_to_backend</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>

            <span class="c1"># Apply selection mask to object copies</span>
            <span class="n">obj_copies</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">obj_copies</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">] Baseline selection: before=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="si">}</span><span class="s2">, after=</span><span class="si">{</span><span class="n">ak</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="si">}</span><span class="s2"> events&quot;</span><span class="p">)</span>

            <span class="c1"># Compute ghost observables before corrections</span>
            <span class="n">obj_copies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_ghost_observables</span><span class="p">(</span><span class="n">obj_copies</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">] Computed ghost observables&quot;</span><span class="p">)</span>

            <span class="c1"># Apply object-level corrections (nominal direction only)</span>
            <span class="n">obj_copies_corrected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_object_corrections</span><span class="p">(</span>
                <span class="n">obj_copies</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">corrections</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;nominal&quot;</span>
            <span class="p">)</span>
            <span class="n">obj_copies_corrected</span> <span class="o">=</span> <span class="n">recursive_to_backend</span><span class="p">(</span><span class="n">obj_copies_corrected</span><span class="p">,</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">] Applied object corrections&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">obj_copies</span><span class="p">,</span> <span class="n">obj_copies_corrected</span><span class="p">,</span> <span class="n">mask</span>

        <span class="c1"># Choose mask set for MVA branch (&quot;mva&quot; or fallback to &quot;analysis&quot;)</span>
        <span class="n">mva_mask_set</span> <span class="o">=</span> <span class="s2">&quot;mva&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">good_object_masks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mva&quot;</span><span class="p">,</span> <span class="p">[])</span> <span class="k">else</span> <span class="s2">&quot;analysis&quot;</span>

        <span class="c1"># Prepare corrected object copies and masks for both branches</span>
        <span class="n">obj_copies_analysis</span><span class="p">,</span> <span class="n">obj_copies_corrected_analysis</span><span class="p">,</span> <span class="n">mask_analysis</span> <span class="o">=</span> <span class="n">prepare_full_obj_copies</span><span class="p">(</span>
            <span class="n">events</span><span class="p">,</span> <span class="n">mask_set</span><span class="o">=</span><span class="s2">&quot;analysis&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;analysis&quot;</span>
        <span class="p">)</span>
        <span class="n">obj_copies_mva</span><span class="p">,</span> <span class="n">obj_copies_corrected_mva</span><span class="p">,</span> <span class="n">mask_mva</span> <span class="o">=</span> <span class="n">prepare_full_obj_copies</span><span class="p">(</span>
            <span class="n">events</span><span class="p">,</span> <span class="n">mask_set</span><span class="o">=</span><span class="n">mva_mask_set</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;mva&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Extract nominal per-channel data using corrected objects</span>
        <span class="n">channels_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_data</span><span class="p">(</span>
            <span class="n">obj_copies_corrected_analysis</span><span class="p">,</span>
            <span class="n">events</span><span class="p">[</span><span class="n">mask_analysis</span><span class="p">],</span>
            <span class="n">obj_copies_corrected_mva</span><span class="p">,</span>
            <span class="n">events</span><span class="p">[</span><span class="n">mask_mva</span><span class="p">],</span>
            <span class="n">process</span><span class="p">,</span>
            <span class="s2">&quot;nominal&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">channels_data</span><span class="p">[</span><span class="s2">&quot;__presel&quot;</span><span class="p">][</span><span class="s2">&quot;nevents&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ak</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask_analysis</span><span class="p">)</span>
        <span class="n">channels_data</span><span class="p">[</span><span class="s2">&quot;__presel&quot;</span><span class="p">][</span><span class="s2">&quot;mva_nevents&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ak</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask_mva</span><span class="p">)</span>
        <span class="n">processed_data</span><span class="p">[</span><span class="s2">&quot;nominal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">channels_data</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Prepared nominal channel data&quot;</span><span class="p">)</span>

        <span class="c1"># Loop over systematics if enabled</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">run_systematics</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Processing systematic variations...&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">syst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">systematics</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">corrections</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">syst</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;nominal&quot;</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing </span><span class="si">{</span><span class="n">syst</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> systematics&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;up&quot;</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">]:</span>
                    <span class="n">varname</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">syst</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing variation: </span><span class="si">{</span><span class="n">varname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="c1"># Apply systematic correction to object copies</span>
                    <span class="n">obj_copies_corrected_analysis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_object_corrections</span><span class="p">(</span>
                        <span class="n">obj_copies_analysis</span><span class="p">,</span> <span class="p">[</span><span class="n">syst</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="n">direction</span>
                    <span class="p">)</span>
                    <span class="n">obj_copies_corrected_mva</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_object_corrections</span><span class="p">(</span>
                        <span class="n">obj_copies_mva</span><span class="p">,</span> <span class="p">[</span><span class="n">syst</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="n">direction</span>
                    <span class="p">)</span>

                    <span class="c1"># Get channel data for the variation</span>
                    <span class="n">channels_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_data</span><span class="p">(</span>
                        <span class="n">obj_copies_corrected_analysis</span><span class="p">,</span>
                        <span class="n">events</span><span class="p">[</span><span class="n">mask_analysis</span><span class="p">],</span>
                        <span class="n">obj_copies_corrected_mva</span><span class="p">,</span>
                        <span class="n">events</span><span class="p">[</span><span class="n">mask_mva</span><span class="p">],</span>
                        <span class="n">process</span><span class="p">,</span>
                        <span class="n">varname</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">channels_data</span><span class="p">[</span><span class="s2">&quot;__presel&quot;</span><span class="p">][</span><span class="s2">&quot;nevents&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ak</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask_analysis</span><span class="p">)</span>
                    <span class="n">channels_data</span><span class="p">[</span><span class="s2">&quot;__presel&quot;</span><span class="p">][</span><span class="s2">&quot;mva_nevents&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ak</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask_mva</span><span class="p">)</span>
                    <span class="n">processed_data</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">channels_data</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Prepared channel data for </span><span class="si">{</span><span class="n">varname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">processed_data</span>


    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Histogram building</span>
    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_histogramming</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">processed_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">mva_instances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="n">process</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">variation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">xsec_weight</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="n">event_syst</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">direction</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;up&quot;</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">,</span> <span class="s2">&quot;nominal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;nominal&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply selections and fill histograms for each observable and channel.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        processed_data : dict</span>
<span class="sd">            Preprocessed channel data</span>
<span class="sd">        mva_instances : dict[str, Any]</span>
<span class="sd">            Trained MVA instances per MVA name</span>
<span class="sd">        process : str</span>
<span class="sd">            Sample label (e.g., &#39;ttbar&#39;, &#39;data&#39;)</span>
<span class="sd">        variation : str</span>
<span class="sd">            Systematic variation label</span>
<span class="sd">        xsec_weight : float</span>
<span class="sd">            Cross-section normalisation factor</span>
<span class="sd">        params : dict</span>
<span class="sd">            JAX parameters for soft selections and KDE bandwidth</span>
<span class="sd">        event_syst : dict, optional</span>
<span class="sd">            Event-level systematic information</span>
<span class="sd">        direction : str, optional</span>
<span class="sd">            Systematic direction (&#39;up&#39;, &#39;down&#39;, &#39;nominal&#39;)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict[str, jnp.ndarray]</span>
<span class="sd">            Histograms for the channel and observables</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">jax_config</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">jax</span>
        <span class="n">histograms</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

        <span class="c1"># Skip non-nominal variations for data</span>
        <span class="k">if</span> <span class="n">process</span> <span class="o">==</span> <span class="s2">&quot;data&quot;</span> <span class="ow">and</span> <span class="n">variation</span> <span class="o">!=</span> <span class="s2">&quot;nominal&quot;</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping </span><span class="si">{</span><span class="n">variation</span><span class="si">}</span><span class="s2"> for data&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">histograms</span>

        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="c1"># Skip channels not participating in differentiable analysis</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">channel</span><span class="o">.</span><span class="n">use_in_diff</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping channel </span><span class="si">{</span><span class="n">channel</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> (use_in_diff=False)&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">chname</span> <span class="o">=</span> <span class="n">channel</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>

            <span class="c1"># Skip if channel is not listed in requested channels</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">req</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span> <span class="ow">and</span> <span class="n">chname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">req</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping channel </span><span class="si">{</span><span class="n">chname</span><span class="si">}</span><span class="s2"> (not in requested channels)&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing channel: </span><span class="si">{</span><span class="n">chname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Extract object and event data for this channel</span>
            <span class="n">obj_copies_ch</span> <span class="o">=</span> <span class="n">processed_data</span><span class="p">[</span><span class="n">chname</span><span class="p">][</span><span class="s2">&quot;objects&quot;</span><span class="p">]</span>
            <span class="n">events_ch</span> <span class="o">=</span> <span class="n">processed_data</span><span class="p">[</span><span class="n">chname</span><span class="p">][</span><span class="s2">&quot;events&quot;</span><span class="p">]</span>
            <span class="n">nevents</span> <span class="o">=</span> <span class="n">processed_data</span><span class="p">[</span><span class="n">chname</span><span class="p">][</span><span class="s2">&quot;nevents&quot;</span><span class="p">]</span>

            <span class="c1"># Compute MVA features for this channel</span>
            <span class="k">for</span> <span class="n">mva_name</span><span class="p">,</span> <span class="n">mva_instance</span> <span class="ow">in</span> <span class="n">mva_instances</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">mva_features</span> <span class="o">=</span> <span class="n">mva_instance</span><span class="o">.</span><span class="n">_extract_features</span><span class="p">(</span>
                    <span class="n">obj_copies_ch</span><span class="p">,</span>
                    <span class="n">mva_instance</span><span class="o">.</span><span class="n">mva_cfg</span><span class="o">.</span><span class="n">features</span>
                <span class="p">)</span>
                <span class="n">obj_copies_ch</span><span class="p">[</span><span class="n">mva_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;features&quot;</span><span class="p">:</span> <span class="n">mva_features</span><span class="p">,</span>
                    <span class="s2">&quot;instance&quot;</span><span class="p">:</span> <span class="n">mva_instance</span><span class="p">,</span>
                <span class="p">}</span>

            <span class="c1"># Move data to JAX backend</span>
            <span class="n">obj_copies_ch</span> <span class="o">=</span> <span class="n">recursive_to_backend</span><span class="p">(</span><span class="n">obj_copies_ch</span><span class="p">,</span> <span class="s2">&quot;jax&quot;</span><span class="p">)</span>
            <span class="n">events_ch</span> <span class="o">=</span> <span class="n">recursive_to_backend</span><span class="p">(</span><span class="n">events_ch</span><span class="p">,</span> <span class="s2">&quot;jax&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel </span><span class="si">{</span><span class="n">chname</span><span class="si">}</span><span class="s2"> has </span><span class="si">{</span><span class="n">nevents</span><span class="si">}</span><span class="s2"> events&quot;</span><span class="p">)</span>

            <span class="c1"># Compute differentiable selection weights using soft cut function</span>
            <span class="n">diff_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_function_arguments</span><span class="p">(</span>
                <span class="n">jax_config</span><span class="o">.</span><span class="n">soft_selection</span><span class="o">.</span><span class="n">use</span><span class="p">,</span> <span class="n">obj_copies_ch</span>
            <span class="p">)</span>
            <span class="n">diff_weights</span> <span class="o">=</span> <span class="n">jax_config</span><span class="o">.</span><span class="n">soft_selection</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">diff_args</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computed differentiable weights&quot;</span><span class="p">)</span>

            <span class="c1"># Compute cross-section normalised event weights</span>
            <span class="k">if</span> <span class="n">process</span> <span class="o">!=</span> <span class="s2">&quot;data&quot;</span><span class="p">:</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="p">(</span><span class="n">events_ch</span><span class="o">.</span><span class="n">genWeight</span> <span class="o">*</span> <span class="n">xsec_weight</span><span class="p">)</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">events_ch</span><span class="o">.</span><span class="n">genWeight</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MC weights: xsec_weight=</span><span class="si">{</span><span class="n">xsec_weight</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="n">ak</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nevents</span><span class="p">))</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Using unit weights for data&quot;</span><span class="p">)</span>

            <span class="c1"># Apply event-level systematic correction if available</span>
            <span class="k">if</span> <span class="n">event_syst</span> <span class="ow">and</span> <span class="n">process</span> <span class="o">!=</span> <span class="s2">&quot;data&quot;</span><span class="p">:</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_event_weight_correction</span><span class="p">(</span>
                    <span class="n">weights</span><span class="p">,</span> <span class="n">event_syst</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">obj_copies_ch</span>
                <span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Applied </span><span class="si">{</span><span class="n">event_syst</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2"> correction&quot;</span><span class="p">)</span>

            <span class="n">weights</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ak</span><span class="o">.</span><span class="n">to_jax</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Events in </span><span class="si">{</span><span class="n">chname</span><span class="si">}</span><span class="s2">: raw=</span><span class="si">{</span><span class="n">nevents</span><span class="si">}</span><span class="s2">, weighted=</span><span class="si">{</span><span class="n">ak</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="c1"># Loop over observables and compute KDE-based histograms</span>
            <span class="k">for</span> <span class="n">observable</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">[</span><span class="s2">&quot;observables&quot;</span><span class="p">]:</span>
                <span class="n">obs_name</span> <span class="o">=</span> <span class="n">observable</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>

                <span class="c1"># Skip observables that are not JAX-compatible</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">observable</span><span class="o">.</span><span class="n">works_with_jax</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping </span><span class="si">{</span><span class="n">obs_name</span><span class="si">}</span><span class="s2"> - not JAX-compatible&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing observable: </span><span class="si">{</span><span class="n">obs_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># Evaluate observable function</span>
                <span class="n">obs_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_function_arguments</span><span class="p">(</span><span class="n">observable</span><span class="p">[</span><span class="s2">&quot;use&quot;</span><span class="p">],</span> <span class="n">obj_copies_ch</span><span class="p">)</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ak</span><span class="o">.</span><span class="n">to_jax</span><span class="p">(</span><span class="n">observable</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">](</span><span class="o">*</span><span class="n">obs_args</span><span class="p">)))</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computed </span><span class="si">{</span><span class="n">obs_name</span><span class="si">}</span><span class="s2"> values&quot;</span><span class="p">)</span>

                <span class="c1"># Parse binning specification</span>
                <span class="n">binning</span> <span class="o">=</span> <span class="n">observable</span><span class="p">[</span><span class="s2">&quot;binning&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binning</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">nbins</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">binning</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">))</span>
                    <span class="n">binning</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">nbins</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">binning</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">binning</span><span class="p">)</span>

                <span class="c1"># Kernel bandwidth for KDE</span>
                <span class="n">bandwidth</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;kde_bandwidth&quot;</span><span class="p">]</span>

                <span class="c1"># Compute cumulative density function (CDF) for each bin edge</span>
                <span class="n">cdf</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span>
                    <span class="n">binning</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                    <span class="n">loc</span><span class="o">=</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                    <span class="n">scale</span><span class="o">=</span><span class="n">bandwidth</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Multiply CDF by per-event weights and compute bin contributions</span>
                <span class="n">weighted_cdf</span> <span class="o">=</span> <span class="n">cdf</span> <span class="o">*</span> <span class="n">diff_weights</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">weights</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">bin_weights</span> <span class="o">=</span> <span class="n">weighted_cdf</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">weighted_cdf</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">histogram</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bin_weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1"># Store histogram and binning</span>
                <span class="n">histograms</span><span class="p">[</span><span class="n">chname</span><span class="p">][</span><span class="n">obs_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">histogram</span><span class="p">),</span> <span class="n">binning</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filled histogram for </span><span class="si">{</span><span class="n">obs_name</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">chname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">histograms</span>


    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Histogram collection</span>
    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_collect_histograms</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">processed_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ak</span><span class="o">.</span><span class="n">Array</span><span class="p">]],</span>
        <span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="n">params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run full analysis logic on events from one dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        processed_data : dict</span>
<span class="sd">            Per-variation channel data from `._prepare_data_for_tracing`</span>
<span class="sd">        metadata : dict</span>
<span class="sd">            Dataset metadata with keys:</span>
<span class="sd">            - &#39;process&#39;: process name</span>
<span class="sd">            - &#39;xsec&#39;: cross-section</span>
<span class="sd">            - &#39;nevts&#39;: number of generated events</span>
<span class="sd">            - &#39;dataset&#39;: dataset name</span>
<span class="sd">        params : dict</span>
<span class="sd">            JAX parameters for histogramming</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Histograms keyed by variation/channel/observable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_histograms</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">))</span>
        <span class="n">process</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;process&quot;</span><span class="p">]</span>
        <span class="n">xsec</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;xsec&quot;</span><span class="p">]</span>
        <span class="n">n_gen</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nevts&quot;</span><span class="p">]</span>
        <span class="n">lumi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;general&quot;</span><span class="p">][</span><span class="s2">&quot;lumi&quot;</span><span class="p">]</span>

        <span class="c1"># Calculate cross-section weight for MC (unit weight for data)</span>
        <span class="n">xsec_weight</span> <span class="o">=</span> <span class="p">(</span><span class="n">xsec</span> <span class="o">*</span> <span class="n">lumi</span> <span class="o">/</span> <span class="n">n_gen</span><span class="p">)</span> <span class="k">if</span> <span class="n">process</span> <span class="o">!=</span> <span class="s2">&quot;data&quot;</span> <span class="k">else</span> <span class="mf">1.0</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Process: </span><span class="si">{</span><span class="n">process</span><span class="si">}</span><span class="s2">, xsec: </span><span class="si">{</span><span class="n">xsec</span><span class="si">}</span><span class="s2">, n_gen: </span><span class="si">{</span><span class="n">n_gen</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;lumi: </span><span class="si">{</span><span class="n">lumi</span><span class="si">}</span><span class="s2">, weight: </span><span class="si">{</span><span class="n">xsec_weight</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Nominal histogramming</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing nominal variation for </span><span class="si">{</span><span class="n">process</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">histograms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_histogramming</span><span class="p">(</span>
            <span class="n">processed_data</span><span class="p">[</span><span class="s2">&quot;nominal&quot;</span><span class="p">],</span>
            <span class="n">processed_data</span><span class="p">[</span><span class="s2">&quot;mva_nets&quot;</span><span class="p">],</span>
            <span class="n">process</span><span class="p">,</span>
            <span class="s2">&quot;nominal&quot;</span><span class="p">,</span>
            <span class="n">xsec_weight</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">all_histograms</span><span class="p">[</span><span class="s2">&quot;nominal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">histograms</span>

        <span class="c1"># Loop over systematics (if enabled)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">run_systematics</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing systematics for </span><span class="si">{</span><span class="n">process</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">syst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">systematics</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">corrections</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">syst</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;nominal&quot;</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;up&quot;</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">]:</span>
                    <span class="n">varname</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">syst</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing </span><span class="si">{</span><span class="n">varname</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="n">process</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="n">histograms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_histogramming</span><span class="p">(</span>
                        <span class="n">processed_data</span><span class="p">[</span><span class="n">varname</span><span class="p">],</span>
                        <span class="n">processed_data</span><span class="p">[</span><span class="s2">&quot;mva_nets&quot;</span><span class="p">],</span>
                        <span class="n">process</span><span class="p">,</span>
                        <span class="n">varname</span><span class="p">,</span>
                        <span class="n">xsec_weight</span><span class="p">,</span>
                        <span class="n">params</span><span class="p">,</span>
                        <span class="n">event_syst</span><span class="o">=</span><span class="n">syst</span><span class="p">,</span>
                        <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">all_histograms</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">histograms</span>

        <span class="k">return</span> <span class="n">all_histograms</span>


    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Significance Calculation</span>
    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_calculate_significance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">process_histograms</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">recreate_fit_params</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate asymptotic significance using evermore with multi-channel modelling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        process_histograms : dict</span>
<span class="sd">            Histograms organised by process, variation, region and observable.</span>
<span class="sd">        params : dict</span>
<span class="sd">            Fit parameters for significance calculation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        jnp.ndarray</span>
<span class="sd">            Asymptotic significance (sqrt(q0)) from profile likelihood ratio.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;📊 Calculating significance from histograms...&quot;</span><span class="p">)</span>

        <span class="c1"># Convert histograms to standard Python dictionaries (from nested defaultdicts)</span>
        <span class="n">histograms</span> <span class="o">=</span> <span class="n">nested_defaultdict_to_dict</span><span class="p">(</span><span class="n">process_histograms</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Use relaxed to compute significance and maximum likelihood estimators</span>
        <span class="n">significance</span><span class="p">,</span> <span class="n">mle_pars</span> <span class="o">=</span> <span class="n">calculate_significance_relaxed</span><span class="p">(</span><span class="n">histograms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;✅ Significance calculation complete</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">significance</span><span class="p">,</span> <span class="n">mle_pars</span>


    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># The analysis workflow being optimised [histograms + statistics]</span>
    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_run_traced_analysis_chain</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="n">processed_data_events</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collect histograms from preprocessed events and compute the final statistical significance.</span>

<span class="sd">        This function iterates over the preprocessed events, builds histograms for each dataset</span>
<span class="sd">        and process, merges them, and then computes the overall significance using a profile</span>
<span class="sd">        likelihood fit. The resulting histograms are also stored for later access (e.g. plotting).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : dict</span>
<span class="sd">            Dictionary of model parameters containing:</span>
<span class="sd">            - &#39;aux&#39;: Auxiliary parameters (e.g. selection thresholds, nuisance parameters)</span>
<span class="sd">            - &#39;fit&#39;: Fit parameters for statistical inference (e.g. normalization factors)</span>
<span class="sd">        processed_data_events : dict</span>
<span class="sd">            Nested dictionary containing preprocessed events produced by `run_analysis_processing`.</span>
<span class="sd">            Structure:</span>
<span class="sd">            {</span>
<span class="sd">                &quot;&lt;dataset&gt;&quot;: {</span>
<span class="sd">                    &quot;&lt;file_key&gt;&quot;: {</span>
<span class="sd">                        &quot;&lt;variation&gt;&quot;: (processed_data, metadata),</span>
<span class="sd">                        ...</span>
<span class="sd">                    },</span>
<span class="sd">                    ...</span>
<span class="sd">                },</span>
<span class="sd">                ...</span>
<span class="sd">            }</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            significance : jnp.ndarray</span>
<span class="sd">                The computed asymptotic significance value.</span>
<span class="sd">            mle_params : dict</span>
<span class="sd">                The maximum-likelihood estimated fit parameters obtained from the significance fit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;📊 Starting histogram collection and significance calculation...&quot;</span><span class="p">)</span>
        <span class="n">histograms_by_process</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

        <span class="c1"># -------------------------------------------------------------------------</span>
        <span class="c1"># Loop over datasets (e.g. &#39;2018___ttbar&#39;, &#39;2018___wjets&#39;)</span>
        <span class="c1"># -------------------------------------------------------------------------</span>
        <span class="k">for</span> <span class="n">dataset_name</span><span class="p">,</span> <span class="n">dataset_files</span> <span class="ow">in</span> <span class="n">processed_data_events</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">process_name</span> <span class="o">=</span> <span class="n">dataset_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;___&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;🔍 Processing dataset: </span><span class="si">{</span><span class="n">dataset_name</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(process: </span><span class="si">{</span><span class="n">process_name</span><span class="si">}</span><span class="s2">, files: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset_files</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

            <span class="c1"># Ensure process histogram container exists</span>
            <span class="k">if</span> <span class="n">process_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">histograms_by_process</span><span class="p">:</span>
                <span class="n">histograms_by_process</span><span class="p">[</span><span class="n">process_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">))</span>

            <span class="c1"># ---------------------------------------------------------------------</span>
            <span class="c1"># Loop over files in the dataset</span>
            <span class="c1"># ---------------------------------------------------------------------</span>
            <span class="k">for</span> <span class="n">file_key</span><span class="p">,</span> <span class="n">variations</span> <span class="ow">in</span> <span class="n">dataset_files</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">variation_name</span><span class="p">,</span> <span class="p">(</span><span class="n">processed_data</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span> <span class="ow">in</span> <span class="n">variations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  • Collecting histograms for file: </span><span class="si">{</span><span class="n">file_key</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">variation_name</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

                    <span class="c1"># Build histograms for this file and variation</span>
                    <span class="n">file_histograms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collect_histograms</span><span class="p">(</span><span class="n">processed_data</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;aux&quot;</span><span class="p">])</span>

                    <span class="c1"># Merge file histograms into the global container for this process</span>
                    <span class="n">histograms_by_process</span><span class="p">[</span><span class="n">process_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">merge_histograms</span><span class="p">(</span>
                        <span class="n">histograms_by_process</span><span class="p">[</span><span class="n">process_name</span><span class="p">],</span> <span class="nb">dict</span><span class="p">(</span><span class="n">file_histograms</span><span class="p">)</span>
                    <span class="p">)</span>

        <span class="c1"># -------------------------------------------------------------------------</span>
        <span class="c1"># Compute statistical significance from histograms</span>
        <span class="c1"># -------------------------------------------------------------------------</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;✅ Histogram collection complete. Starting significance calculation...&quot;</span><span class="p">)</span>
        <span class="n">significance</span><span class="p">,</span> <span class="n">mle_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_significance</span><span class="p">(</span><span class="n">histograms_by_process</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;fit&quot;</span><span class="p">])</span>

        <span class="c1"># Store histograms for later plotting or debugging</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_histograms</span><span class="p">(</span><span class="n">histograms_by_process</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">significance</span><span class="p">,</span> <span class="n">mle_params</span>


    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Run the data processing code</span>
    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_prepare_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="n">fileset</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="n">read_from_cache</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">run_and_cache</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">cache_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;/tmp/gradients_analysis/&quot;</span><span class="p">,</span>
        <span class="n">recreate_fit_params</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run full analysis on all datasets in fileset with caching support.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : dict</span>
<span class="sd">            Analysis parameters.</span>
<span class="sd">        fileset : dict</span>
<span class="sd">            Dictionary mapping dataset names to file and metadata.</span>
<span class="sd">        read_from_cache : bool</span>
<span class="sd">            Read preprocessed events from cache.</span>
<span class="sd">        run_and_cache : bool</span>
<span class="sd">            Process events and cache results.</span>
<span class="sd">        cache_dir : str, optional</span>
<span class="sd">            Directory for cached events.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Preprocessed events keyed by dataset and file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">config</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span>
        <span class="n">all_events</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">))</span>

        <span class="c1"># Prepare dictionary to collect MVA training data</span>
        <span class="n">mva_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">mva_cfg</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">mva</span> <span class="ow">or</span> <span class="p">[]:</span>
            <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">mva_cfg</span><span class="o">.</span><span class="n">classes</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">mva_data</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="p">[])</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">class_name</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                    <span class="n">mva_data</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">class_name</span><span class="p">,</span> <span class="p">[])</span>

        <span class="c1"># Loop over datasets in the fileset</span>
        <span class="k">for</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">content</span> <span class="ow">in</span> <span class="n">fileset</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="n">content</span><span class="p">[</span><span class="s2">&quot;metadata&quot;</span><span class="p">]</span>
            <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;dataset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataset</span>
            <span class="n">process_name</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;process&quot;</span><span class="p">]</span>

            <span class="c1"># Skip datasets not explicitly requested in config</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">req</span> <span class="o">:=</span> <span class="n">config</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">processes</span><span class="p">)</span> <span class="ow">and</span> <span class="n">process_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">req</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping </span><span class="si">{</span><span class="n">dataset</span><span class="si">}</span><span class="s2"> (process </span><span class="si">{</span><span class="n">process_name</span><span class="si">}</span><span class="s2"> not in requested)&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;========================================&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;🚀 Processing dataset: </span><span class="si">{</span><span class="n">dataset</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">process_name</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

            <span class="c1"># Loop over ROOT files associated with the dataset</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">content</span><span class="p">[</span><span class="s2">&quot;files&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>

                <span class="c1"># Honour file limit if set in configuration</span>
                <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">max_files</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">config</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">max_files</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reached max files limit (</span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">max_files</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                    <span class="k">break</span>

                <span class="c1"># Determine output directory for preprocessed files</span>
                <span class="n">output_dir</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;output/</span><span class="si">{</span><span class="n">dataset</span><span class="si">}</span><span class="s2">/file__</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">/&quot;</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">config</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">preprocessed_dir</span>
                    <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">preprocessed_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">dataset</span><span class="si">}</span><span class="s2">/file__</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">/&quot;</span>
                <span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Preprocessed files directory: </span><span class="si">{</span><span class="n">output_dir</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># Preprocess ROOT files into skimmed format using uproot or dask</span>
                <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">run_preprocessing</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;🔍 Preprocessing input file: </span><span class="si">{</span><span class="n">file_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;➡️  Writing to: </span><span class="si">{</span><span class="n">output_dir</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">preprocessor</span> <span class="o">==</span> <span class="s2">&quot;uproot&quot;</span><span class="p">:</span>
                        <span class="n">pre_process_uproot</span><span class="p">(</span>
                            <span class="n">file_path</span><span class="p">,</span>
                            <span class="n">tree</span><span class="p">,</span>
                            <span class="n">output_dir</span><span class="p">,</span>
                            <span class="n">config</span><span class="p">,</span>
                            <span class="n">is_mc</span><span class="o">=</span><span class="p">(</span><span class="n">dataset</span> <span class="o">!=</span> <span class="s2">&quot;data&quot;</span><span class="p">),</span>
                        <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">config</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">preprocessor</span> <span class="o">==</span> <span class="s2">&quot;dask&quot;</span><span class="p">:</span>
                        <span class="n">pre_process_dak</span><span class="p">(</span>
                            <span class="n">file_path</span><span class="p">,</span>
                            <span class="n">tree</span><span class="p">,</span>
                            <span class="n">output_dir</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;/part</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">.root&quot;</span><span class="p">,</span>
                            <span class="n">config</span><span class="p">,</span>
                            <span class="n">is_mc</span><span class="o">=</span><span class="p">(</span><span class="n">dataset</span> <span class="o">!=</span> <span class="s2">&quot;data&quot;</span><span class="p">),</span>
                        <span class="p">)</span>

                <span class="c1"># Discover skimmed files and summarise retained events</span>
                <span class="n">skimmed_files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">output_dir</span><span class="si">}</span><span class="s2">/part*.root&quot;</span><span class="p">)</span>
                <span class="n">skimmed_files</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">tree</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">skimmed_files</span><span class="p">]</span>
                <span class="n">remaining</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">uproot</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">num_entries</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">skimmed_files</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;📘 Events retained after filtering: </span><span class="si">{</span><span class="n">remaining</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># Loop over skimmed files for further processing and caching</span>
                <span class="k">for</span> <span class="n">skimmed</span> <span class="ow">in</span> <span class="n">skimmed_files</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;📘 Processing skimmed file: </span><span class="si">{</span><span class="n">skimmed</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">cache_key</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="n">skimmed</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
                    <span class="n">cache_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cache_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dataset</span><span class="si">}</span><span class="s2">__</span><span class="si">{</span><span class="n">cache_key</span><span class="si">}</span><span class="s2">.pkl&quot;</span><span class="p">)</span>

                    <span class="c1"># Handle caching: process and cache, read from cache, or skip</span>
                    <span class="k">if</span> <span class="n">run_and_cache</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing and caching: </span><span class="si">{</span><span class="n">skimmed</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">events</span> <span class="o">=</span> <span class="n">NanoEventsFactory</span><span class="o">.</span><span class="n">from_root</span><span class="p">(</span>
                            <span class="n">skimmed</span><span class="p">,</span> <span class="n">schemaclass</span><span class="o">=</span><span class="n">NanoAODSchema</span><span class="p">,</span> <span class="n">delayed</span><span class="o">=</span><span class="kc">False</span>
                        <span class="p">)</span><span class="o">.</span><span class="n">events</span><span class="p">()</span>
                        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">cache_file</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                            <span class="n">cloudpickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;💾 Cached events to </span><span class="si">{</span><span class="n">cache_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">read_from_cache</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cache_file</span><span class="p">):</span>
                            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">cache_file</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                                <span class="n">events</span> <span class="o">=</span> <span class="n">cloudpickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;🔁 Loaded cached events from </span><span class="si">{</span><span class="n">cache_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cache file not found: </span><span class="si">{</span><span class="n">cache_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="n">events</span> <span class="o">=</span> <span class="n">NanoEventsFactory</span><span class="o">.</span><span class="n">from_root</span><span class="p">(</span>
                                <span class="n">skimmed</span><span class="p">,</span> <span class="n">schemaclass</span><span class="o">=</span><span class="n">NanoAODSchema</span><span class="p">,</span> <span class="n">delayed</span><span class="o">=</span><span class="kc">False</span>
                            <span class="p">)</span><span class="o">.</span><span class="n">events</span><span class="p">()</span>
                            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">cache_file</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                                <span class="n">cloudpickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;💾 Created new cache: </span><span class="si">{</span><span class="n">cache_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">events</span> <span class="o">=</span> <span class="n">NanoEventsFactory</span><span class="o">.</span><span class="n">from_root</span><span class="p">(</span>
                            <span class="n">skimmed</span><span class="p">,</span> <span class="n">schemaclass</span><span class="o">=</span><span class="n">NanoAODSchema</span><span class="p">,</span> <span class="n">delayed</span><span class="o">=</span><span class="kc">False</span>
                        <span class="p">)</span><span class="o">.</span><span class="n">events</span><span class="p">()</span>

                    <span class="c1"># Run preprocessing pipeline and store processed results</span>
                    <span class="n">processed_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_data_for_tracing</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">process_name</span><span class="p">)</span>
                    <span class="n">all_events</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dataset</span><span class="si">}</span><span class="s2">___</span><span class="si">{</span><span class="n">process_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="sa">f</span><span class="s2">&quot;file__</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="n">skimmed</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">processed_data</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>

                    <span class="c1"># Collect training data for MVA, if enabled</span>
                    <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">mva</span> <span class="ow">and</span> <span class="n">config</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">run_mva_training</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">mva_cfg</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">mva</span><span class="p">:</span>
                            <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">mva_cfg</span><span class="o">.</span><span class="n">classes</span><span class="p">:</span>
                                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                                    <span class="n">class_name</span> <span class="o">=</span> <span class="bp">cls</span>
                                    <span class="n">proc_names</span> <span class="o">=</span> <span class="p">[</span><span class="bp">cls</span><span class="p">]</span>
                                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                                    <span class="n">class_name</span><span class="p">,</span> <span class="n">proc_names</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="k">continue</span>

                                <span class="k">if</span> <span class="n">process_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">proc_names</span><span class="p">:</span>
                                    <span class="k">continue</span>

                                <span class="n">nominal_channels</span> <span class="o">=</span> <span class="n">processed_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nominal&quot;</span><span class="p">,</span> <span class="p">{})</span>
                                <span class="k">if</span> <span class="n">nominal_channels</span><span class="p">:</span>
                                    <span class="n">presel_ch</span> <span class="o">=</span> <span class="n">nominal_channels</span><span class="p">[</span><span class="s2">&quot;__presel&quot;</span><span class="p">]</span>

                                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                                        <span class="sa">f</span><span class="s2">&quot;Adding </span><span class="si">{</span><span class="n">presel_ch</span><span class="p">[</span><span class="s1">&#39;mva_nevents&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> events from process &#39;</span><span class="si">{</span><span class="n">process_name</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                                        <span class="sa">f</span><span class="s2">&quot;to MVA training class &#39;</span><span class="si">{</span><span class="n">class_name</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                                    <span class="p">)</span>

                                    <span class="n">mva_data</span><span class="p">[</span><span class="n">class_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="p">(</span><span class="n">presel_ch</span><span class="p">[</span><span class="s2">&quot;mva_objects&quot;</span><span class="p">],</span> <span class="n">presel_ch</span><span class="p">[</span><span class="s2">&quot;mva_nevents&quot;</span><span class="p">])</span>
                                    <span class="p">)</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;✅ Finished dataset: </span><span class="si">{</span><span class="n">dataset</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Run MVA training after all datasets are processed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">run_mva_training</span> <span class="ow">and</span> <span class="p">(</span><span class="n">mva_cfg</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">mva</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Executing MVA pre-training&quot;</span><span class="p">)</span>
            <span class="n">models</span><span class="p">,</span> <span class="n">nets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_mva_training</span><span class="p">(</span><span class="n">mva_data</span><span class="p">)</span>

        <span class="c1"># Save trained models and attach to processed data</span>
        <span class="k">for</span> <span class="n">model_name</span> <span class="ow">in</span> <span class="n">models</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">models</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span>
            <span class="n">net</span> <span class="o">=</span> <span class="n">nets</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span>
            <span class="n">model_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirs</span><span class="p">[</span><span class="s2">&quot;mva_models&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">model_name</span><span class="si">}</span><span class="s2">.pkl&quot;</span>
            <span class="n">net_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirs</span><span class="p">[</span><span class="s2">&quot;mva_models&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">model_name</span><span class="si">}</span><span class="s2">_network.pkl&quot;</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">model_path</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">cloudpickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">net_path</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">cloudpickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved MVA model &#39;</span><span class="si">{</span><span class="n">model_name</span><span class="si">}</span><span class="s2">&#39; to </span><span class="si">{</span><span class="n">model_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved model network &#39;</span><span class="si">{</span><span class="n">model_name</span><span class="si">}</span><span class="s2">&#39; to </span><span class="si">{</span><span class="n">net_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Attach MVA nets to each file’s processed data</span>
            <span class="k">for</span> <span class="n">dataset_files</span> <span class="ow">in</span> <span class="n">all_events</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">file_dict</span> <span class="ow">in</span> <span class="n">dataset_files</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">skim_key</span><span class="p">,</span> <span class="p">(</span><span class="n">processed_data</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span> <span class="ow">in</span> <span class="n">file_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">processed_data</span><span class="p">[</span><span class="s1">&#39;mva_nets&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nets</span>

        <span class="k">return</span> <span class="n">all_events</span><span class="p">,</span> <span class="n">models</span>


    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Cut Optimisation via Gradient Ascent</span>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="DifferentiableAnalysis.run_analysis_optimisation">
<a class="viewcode-back" href="../../api/analysis.html#analysis.diff.DifferentiableAnalysis.run_analysis_optimisation">[docs]</a>
    <span class="k">def</span> <span class="nf">run_analysis_optimisation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">fileset</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform gradient-based optimisation of analysis selection cuts and MVA parameters.</span>

<span class="sd">        This function runs the entire workflow:</span>
<span class="sd">        - Reads and preprocesses events</span>
<span class="sd">        - Runs the initial (unoptimised) analysis and caches the result</span>
<span class="sd">        - Computes gradients and optimises selection and fit parameters</span>
<span class="sd">        - Saves optimised MVA parameters and produces pre/post-fit plots</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fileset : dict</span>
<span class="sd">            Mapping of dataset names to metadata and ROOT file paths</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            - Dictionary of final optimised KDE-based histograms</span>
<span class="sd">            - Final JAX scalar significance value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ---------------------------------------------------------------------</span>
        <span class="c1"># 1. Configure caching and initialise analysis parameters</span>
        <span class="c1"># ---------------------------------------------------------------------</span>
        <span class="n">cache_dir</span> <span class="o">=</span> <span class="s2">&quot;/tmp/gradients_analysis/&quot;</span>
        <span class="n">read_from_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">read_from_cache</span>
        <span class="n">run_and_cache</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">read_from_cache</span>

        <span class="c1"># Copy soft selection and NN parameters from config</span>
        <span class="n">auxiliary_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">jax</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">all_parameters</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;aux&quot;</span><span class="p">:</span> <span class="n">auxiliary_parameters</span><span class="p">,</span>
            <span class="s2">&quot;fit&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;mu&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s2">&quot;norm_ttbar_semilep&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">},</span>
        <span class="p">}</span>

        <span class="c1"># ---------------------------------------------------------------------</span>
        <span class="c1"># 2. Preprocess events and extract MVA models (if any)</span>
        <span class="c1"># ---------------------------------------------------------------------</span>
        <span class="n">processed_data</span><span class="p">,</span> <span class="n">mva_models</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_data</span><span class="p">(</span>
            <span class="n">all_parameters</span><span class="p">,</span>
            <span class="n">fileset</span><span class="p">,</span>
            <span class="n">read_from_cache</span><span class="o">=</span><span class="n">read_from_cache</span><span class="p">,</span>
            <span class="n">run_and_cache</span><span class="o">=</span><span class="n">run_and_cache</span><span class="p">,</span>
            <span class="n">cache_dir</span><span class="o">=</span><span class="n">cache_dir</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Add MVA model parameters to aux tree (flattened by name)</span>
        <span class="k">for</span> <span class="n">model_name</span><span class="p">,</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">mva_models</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">model_parameters</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">model_parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">all_parameters</span><span class="p">[</span><span class="s2">&quot;aux&quot;</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># Ensure all parameters are JAX arrays</span>
        <span class="n">all_parameters</span><span class="p">[</span><span class="s2">&quot;aux&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">all_parameters</span><span class="p">[</span><span class="s2">&quot;aux&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">all_parameters</span><span class="p">[</span><span class="s2">&quot;fit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">all_parameters</span><span class="p">[</span><span class="s2">&quot;fit&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Initial parameters: </span><span class="si">{</span><span class="n">pformat</span><span class="p">(</span><span class="n">all_parameters</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;✅ Event preprocessing complete</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># ---------------------------------------------------------------------</span>
        <span class="c1"># 3. Run initial traced analysis to compute KDE histograms</span>
        <span class="c1"># ---------------------------------------------------------------------</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;=== Running initial significance computation (traced)... ===&quot;</span><span class="p">)</span>
        <span class="n">initial_significance</span><span class="p">,</span> <span class="n">mle_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_traced_analysis_chain</span><span class="p">(</span>
            <span class="n">all_parameters</span><span class="p">,</span> <span class="n">processed_data</span>
        <span class="p">)</span>
        <span class="n">initial_histograms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">histograms</span>

        <span class="c1"># ---------------------------------------------------------------------</span>
        <span class="c1"># 4. If not just plotting, begin gradient-based optimisation</span>
        <span class="c1"># ---------------------------------------------------------------------</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">run_plots_only</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;=== Beginning cut and NN parameter optimisation ===&quot;</span><span class="p">)</span>

            <span class="c1"># Collect relevant processes and systematics</span>
            <span class="n">processes</span><span class="p">,</span> <span class="n">systematics</span> <span class="o">=</span> <span class="n">infer_processes_and_systematics</span><span class="p">(</span>
                <span class="n">fileset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">systematics</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">corrections</span>
            <span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processes: </span><span class="si">{</span><span class="n">processes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Systematics: </span><span class="si">{</span><span class="n">systematics</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Compute initial gradients to seed optimiser</span>
            <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="n">gradients</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">value_and_grad</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_run_traced_analysis_chain</span><span class="p">,</span>
                <span class="n">has_aux</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">argnums</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)(</span><span class="n">all_parameters</span><span class="p">,</span> <span class="n">processed_data</span><span class="p">)</span>

            <span class="c1"># Define objective for optimiser (significance to maximise)</span>
            <span class="k">def</span> <span class="nf">objective</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_traced_analysis_chain</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">processed_data</span><span class="p">)</span>

            <span class="c1"># Build parameter update/clamping logic</span>
            <span class="n">clamp_fn</span> <span class="o">=</span> <span class="n">make_apply_param_updates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">jax</span><span class="o">.</span><span class="n">param_updates</span><span class="p">)</span>

            <span class="c1"># Configure learning rates</span>
            <span class="n">global_lr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">jax</span><span class="o">.</span><span class="n">learning_rate</span>
            <span class="n">manual_lrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">jax</span><span class="o">.</span><span class="n">learning_rates</span> <span class="ow">or</span> <span class="p">{}</span>
            <span class="n">nn_config_lr</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">frozen_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">mva_cfg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">mva</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">mva_cfg</span><span class="o">.</span><span class="n">grad_optimisation</span><span class="o">.</span><span class="n">optimise</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">all_parameters</span><span class="p">[</span><span class="s2">&quot;aux&quot;</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="s2">&quot;__NN&quot;</span> <span class="ow">in</span> <span class="n">name</span> <span class="ow">and</span> <span class="n">mva_cfg</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
                            <span class="n">frozen_keys</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nn_config_lr</span><span class="p">[</span><span class="n">mva_cfg</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">mva_cfg</span><span class="o">.</span><span class="n">grad_optimisation</span><span class="o">.</span><span class="n">learning_rate</span>


            <span class="c1"># Construct optimiser with clamping</span>
            <span class="n">tx</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">make_lr_and_clamp_transform</span><span class="p">(</span>
                <span class="n">manual_lrs</span><span class="p">,</span>
                <span class="n">default_auxiliary_lr</span><span class="o">=</span><span class="n">global_lr</span><span class="p">,</span>
                <span class="n">default_fit_lr</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span>
                <span class="n">neural_net_lr_map</span><span class="o">=</span><span class="n">nn_config_lr</span><span class="p">,</span>
                <span class="n">clamp_function</span><span class="o">=</span><span class="n">clamp_fn</span><span class="p">,</span>
                <span class="n">frozen_parameter_keys</span><span class="o">=</span><span class="n">frozen_keys</span><span class="p">,</span>
            <span class="p">)(</span><span class="n">all_parameters</span><span class="p">)</span>

            <span class="c1"># Set up optimisation loop</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;== Starting gradient-based optimisation ==&quot;</span><span class="p">)</span>
            <span class="n">initial_params</span> <span class="o">=</span> <span class="n">all_parameters</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">pval_history</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">aux_history</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">all_parameters</span><span class="p">[</span><span class="s2">&quot;aux&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;__NN&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">k</span><span class="p">}</span>
            <span class="n">mle_history</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mle_parameters</span><span class="p">}</span>

            <span class="k">def</span> <span class="nf">optimise_and_log</span><span class="p">(</span><span class="n">n_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
                <span class="n">parameters</span> <span class="o">=</span> <span class="n">initial_params</span>
                <span class="n">solver</span> <span class="o">=</span> <span class="n">OptaxSolver</span><span class="p">(</span>
                    <span class="n">fun</span><span class="o">=</span><span class="n">objective</span><span class="p">,</span>
                    <span class="n">opt</span><span class="o">=</span><span class="n">tx</span><span class="p">,</span>
                    <span class="n">jit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">has_aux</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">value_and_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">maxiter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">jax</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">,</span>
                    <span class="n">tol</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">state</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">init_state</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting explicit optimisation loop...&quot;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_steps</span><span class="p">):</span>
                    <span class="n">new_parameters</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                    <span class="n">parameters</span> <span class="o">=</span> <span class="n">new_parameters</span>

                    <span class="c1"># Record progress</span>
                    <span class="n">pval</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">value</span>
                    <span class="n">mle</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">aux</span>
                    <span class="n">pval_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">pval</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;aux&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="s2">&quot;__NN&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
                            <span class="n">aux_history</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">mle</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">mle_history</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

                    <span class="k">if</span> <span class="n">step</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">jax</span><span class="o">.</span><span class="n">debug</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Step </span><span class="si">{:3d}</span><span class="s2">: p = </span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">pval</span><span class="p">)</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Aux: </span><span class="si">{</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;aux&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  MLE: </span><span class="si">{</span><span class="n">mle</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">state</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">aux</span><span class="p">,</span> <span class="n">parameters</span>

            <span class="c1"># Run optimiser and collect result</span>
            <span class="n">final_pval</span><span class="p">,</span> <span class="n">final_mle_pars</span><span class="p">,</span> <span class="n">final_params</span> <span class="o">=</span> <span class="n">optimise_and_log</span><span class="p">(</span><span class="n">n_steps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">jax</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">)</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Initial p-value: </span><span class="si">{</span><span class="n">initial_significance</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final   p-value: </span><span class="si">{</span><span class="n">final_pval</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Improvement: </span><span class="si">{</span><span class="p">(</span><span class="n">final_pval</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">initial_significance</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">initial_significance</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>

            <span class="c1"># Re-run analysis with final parameters to update histograms</span>
            <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_traced_analysis_chain</span><span class="p">(</span><span class="n">final_params</span><span class="p">,</span> <span class="n">processed_data</span><span class="p">)</span>

            <span class="c1"># Cache optimisation results for later inspection</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cache_dir</span><span class="si">}</span><span class="s2">/cached_result.pkl&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">cloudpickle</span><span class="o">.</span><span class="n">dump</span><span class="p">({</span>
                    <span class="s2">&quot;params&quot;</span><span class="p">:</span> <span class="n">final_params</span><span class="p">,</span>
                    <span class="s2">&quot;mle_pars&quot;</span><span class="p">:</span> <span class="n">final_mle_pars</span><span class="p">,</span>
                    <span class="s2">&quot;significance&quot;</span><span class="p">:</span> <span class="n">final_pval</span><span class="p">,</span>
                    <span class="s2">&quot;histograms&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">histograms</span><span class="p">,</span>
                    <span class="s2">&quot;pvals_history&quot;</span><span class="p">:</span> <span class="n">pval_history</span><span class="p">,</span>
                    <span class="s2">&quot;aux_history&quot;</span><span class="p">:</span> <span class="n">aux_history</span><span class="p">,</span>
                    <span class="s2">&quot;mle_history&quot;</span><span class="p">:</span> <span class="n">mle_history</span><span class="p">,</span>
                    <span class="s2">&quot;gradients&quot;</span><span class="p">:</span> <span class="n">gradients</span><span class="p">,</span>
                <span class="p">},</span> <span class="n">f</span><span class="p">)</span>

            <span class="c1"># Save optimised MVA parameters</span>
            <span class="k">for</span> <span class="n">model_name</span><span class="p">,</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">mva_models</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">optimised_nn_params</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">p</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">final_params</span><span class="p">[</span><span class="s2">&quot;aux&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">if</span> <span class="s2">&quot;__NN&quot;</span> <span class="ow">in</span> <span class="n">p</span> <span class="ow">and</span> <span class="n">model_name</span> <span class="ow">in</span> <span class="n">p</span>
                <span class="p">}</span>
                <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirs</span><span class="p">[</span><span class="s2">&quot;mva_models&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">model_name</span><span class="si">}</span><span class="s2">_optimised.pkl&quot;</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">optimised_nn_params</span><span class="p">),</span> <span class="n">f</span><span class="p">)</span>

        <span class="c1"># ---------------------------------------------------------------------</span>
        <span class="c1"># 5. Reload results and generate summary plots</span>
        <span class="c1"># ---------------------------------------------------------------------</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cache_dir</span><span class="si">}</span><span class="s2">/cached_result.pkl&quot;</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">cloudpickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="n">final_params</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]</span>
        <span class="n">mle_pars</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;mle_pars&quot;</span><span class="p">]</span>
        <span class="n">final_pval</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;significance&quot;</span><span class="p">]</span>
        <span class="n">pval_history</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;pvals_history&quot;</span><span class="p">]</span>
        <span class="n">aux_history</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;aux_history&quot;</span><span class="p">]</span>
        <span class="n">mle_history</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;mle_history&quot;</span><span class="p">]</span>
        <span class="n">gradients</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;gradients&quot;</span><span class="p">]</span>
        <span class="n">histograms</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;histograms&quot;</span><span class="p">]</span>

        <span class="c1"># Generate optimisation progress plots</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">jax</span><span class="o">.</span><span class="n">explicit_optimization</span><span class="p">:</span>
            <span class="n">lrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">jax</span><span class="o">.</span><span class="n">learning_rates</span> <span class="ow">or</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">jax</span><span class="o">.</span><span class="n">learning_rate</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">final_params</span><span class="p">[</span><span class="s2">&quot;aux&quot;</span><span class="p">]}</span>
            <span class="n">plot_pval_history</span><span class="p">(</span><span class="n">pval_history</span><span class="p">,</span> <span class="n">aux_history</span><span class="p">,</span> <span class="n">mle_history</span><span class="p">,</span> <span class="n">gradients</span><span class="p">,</span> <span class="n">lrs</span><span class="p">,</span> <span class="n">plot_settings</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">plotting</span><span class="p">,</span>
                              <span class="n">fname</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dirs</span><span class="p">[</span><span class="s1">&#39;optimisation_plots&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">/pval_history.pdf&quot;</span><span class="p">)</span>

            <span class="n">plot_params_per_iter</span><span class="p">(</span><span class="n">pval_history</span><span class="p">,</span> <span class="n">aux_history</span><span class="p">,</span> <span class="n">mle_history</span><span class="p">,</span> <span class="n">gradients</span><span class="p">,</span> <span class="n">lrs</span><span class="p">,</span> <span class="n">plot_settings</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">plotting</span><span class="p">,</span>
                                 <span class="n">fname</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dirs</span><span class="p">[</span><span class="s1">&#39;optimisation_plots&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">/params_per_iter.pdf&quot;</span><span class="p">)</span>

        <span class="c1"># ---------------------------------------------------------------------</span>
        <span class="c1"># 6. Generate pre- and post-fit plots using significance histograms</span>
        <span class="c1"># ---------------------------------------------------------------------</span>
        <span class="k">def</span> <span class="nf">make_plots</span><span class="p">(</span><span class="n">histograms_dict</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">fitted_pars</span><span class="p">):</span>
            <span class="n">channel_data_list</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">build_allbkg_channel_data_scalar</span><span class="p">(</span><span class="n">histograms_dict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">channel_data</span> <span class="ow">in</span> <span class="n">channel_data_list</span><span class="p">:</span>
                <span class="n">channel_cfg</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">channels</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">channel_data</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">fit_obs</span> <span class="o">=</span> <span class="n">channel_cfg</span><span class="o">.</span><span class="n">fit_observable</span>
                <span class="n">obs_label</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">o</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">channel_cfg</span><span class="p">[</span><span class="s2">&quot;observables&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">o</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">fit_obs</span><span class="p">)</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">plot_cms_histogram</span><span class="p">(</span>
                    <span class="n">bin_edges</span><span class="o">=</span><span class="n">channel_data</span><span class="o">.</span><span class="n">binning</span><span class="p">,</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">channel_data</span><span class="o">.</span><span class="n">data_counts</span><span class="p">,</span>
                    <span class="n">templates</span><span class="o">=</span><span class="n">channel_data</span><span class="o">.</span><span class="n">processes</span><span class="p">,</span>
                    <span class="n">fitted_pars</span><span class="o">=</span><span class="n">fitted_pars</span><span class="p">,</span>
                    <span class="n">plot_settings</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">plotting</span><span class="p">,</span>
                    <span class="n">xlabel</span><span class="o">=</span><span class="n">obs_label</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dirs</span><span class="p">[</span><span class="s1">&#39;fit_plots&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">channel_data</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">.pdf&quot;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>

        <span class="c1"># Plot post-fit (final) and post-fit (initial) comparison</span>
        <span class="n">make_plots</span><span class="p">(</span><span class="n">histograms</span><span class="p">,</span> <span class="s2">&quot;postopt_postfit&quot;</span><span class="p">,</span> <span class="n">mle_pars</span><span class="p">)</span>
        <span class="n">make_plots</span><span class="p">(</span><span class="n">initial_histograms</span><span class="p">,</span> <span class="s2">&quot;preopt_postfit&quot;</span><span class="p">,</span> <span class="n">mle_pars</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">histograms</span><span class="p">,</span> <span class="n">final_pval</span></div>
</div>



</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>